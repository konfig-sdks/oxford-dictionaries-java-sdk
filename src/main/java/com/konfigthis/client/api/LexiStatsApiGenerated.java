/*
 * Oxford Dictionaries
 * Oxford Dictionaries, part of the Oxford Language Division, is a leading authority on the English language. It offers a wide range of language resources, including dictionaries, thesauruses, grammar guides, and language learning tools. Oxford Dictionaries provides accurate and up-to-date definitions, word origins, and usage examples to support language comprehension and communication.
 *
 * The version of the OpenAPI document: 1.11.0
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.NgramsResult;
import com.konfigthis.client.model.StatsWordResult;
import com.konfigthis.client.model.StatsWordResultList;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class LexiStatsApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public LexiStatsApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public LexiStatsApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        if (apiClient.getAppId() == null) {
            throw new IllegalArgumentException("\"app_id\" is required but no API key was provided. Please set \"app_id\" with ApiClient#setAppId(String).");
        }
        if (apiClient.getAppKey() == null) {
            throw new IllegalArgumentException("\"app_key\" is required but no API key was provided. Please set \"app_key\" with ApiClient#setAppKey(String).");
        }
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call getNgramFrequenciesCall(String sourceLang, String corpus, String ngramSize, String tokens, String contains, String punctuation, String format, Long minFrequency, Long maxFrequency, Long minDocumentFrequency, Long maxDocumentFrequency, String collate, String sort, Long offset, Long limit, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/stats/frequency/ngrams/{source_lang}/{corpus}/{ngram-size}"
            .replace("{" + "source_lang" + "}", localVarApiClient.escapeString(sourceLang.toString()))
            .replace("{" + "corpus" + "}", localVarApiClient.escapeString(corpus.toString()))
            .replace("{" + "ngram-size" + "}", localVarApiClient.escapeString(ngramSize.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (tokens != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tokens", tokens));
        }

        if (contains != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("contains", contains));
        }

        if (punctuation != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("punctuation", punctuation));
        }

        if (format != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("format", format));
        }

        if (minFrequency != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minFrequency", minFrequency));
        }

        if (maxFrequency != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxFrequency", maxFrequency));
        }

        if (minDocumentFrequency != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minDocumentFrequency", minDocumentFrequency));
        }

        if (maxDocumentFrequency != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxDocumentFrequency", maxDocumentFrequency));
        }

        if (collate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("collate", collate));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        final String[] localVarAccepts = {
            "application/json",
            "text/csv"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "appId", "appKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getNgramFrequenciesValidateBeforeCall(String sourceLang, String corpus, String ngramSize, String tokens, String contains, String punctuation, String format, Long minFrequency, Long maxFrequency, Long minDocumentFrequency, Long maxDocumentFrequency, String collate, String sort, Long offset, Long limit, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'sourceLang' is set
        if (sourceLang == null) {
            throw new ApiException("Missing the required parameter 'sourceLang' when calling getNgramFrequencies(Async)");
        }

        // verify the required parameter 'corpus' is set
        if (corpus == null) {
            throw new ApiException("Missing the required parameter 'corpus' when calling getNgramFrequencies(Async)");
        }

        // verify the required parameter 'ngramSize' is set
        if (ngramSize == null) {
            throw new ApiException("Missing the required parameter 'ngramSize' when calling getNgramFrequencies(Async)");
        }

        return getNgramFrequenciesCall(sourceLang, corpus, ngramSize, tokens, contains, punctuation, format, minFrequency, maxFrequency, minDocumentFrequency, maxDocumentFrequency, collate, sort, offset, limit, _callback);

    }


    private ApiResponse<NgramsResult> getNgramFrequenciesWithHttpInfo(String sourceLang, String corpus, String ngramSize, String tokens, String contains, String punctuation, String format, Long minFrequency, Long maxFrequency, Long minDocumentFrequency, Long maxDocumentFrequency, String collate, String sort, Long offset, Long limit) throws ApiException {
        okhttp3.Call localVarCall = getNgramFrequenciesValidateBeforeCall(sourceLang, corpus, ngramSize, tokens, contains, punctuation, format, minFrequency, maxFrequency, minDocumentFrequency, maxDocumentFrequency, collate, sort, offset, limit, null);
        Type localVarReturnType = new TypeToken<NgramsResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getNgramFrequenciesAsync(String sourceLang, String corpus, String ngramSize, String tokens, String contains, String punctuation, String format, Long minFrequency, Long maxFrequency, Long minDocumentFrequency, Long maxDocumentFrequency, String collate, String sort, Long offset, Long limit, final ApiCallback<NgramsResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = getNgramFrequenciesValidateBeforeCall(sourceLang, corpus, ngramSize, tokens, contains, punctuation, format, minFrequency, maxFrequency, minDocumentFrequency, maxDocumentFrequency, collate, sort, offset, limit, _callback);
        Type localVarReturnType = new TypeToken<NgramsResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetNgramFrequenciesRequestBuilder {
        private final String sourceLang;
        private final String corpus;
        private final String ngramSize;
        private String tokens;
        private String contains;
        private String punctuation;
        private String format;
        private Long minFrequency;
        private Long maxFrequency;
        private Long minDocumentFrequency;
        private Long maxDocumentFrequency;
        private String collate;
        private String sort;
        private Long offset;
        private Long limit;

        private GetNgramFrequenciesRequestBuilder(String sourceLang, String corpus, String ngramSize) {
            this.sourceLang = sourceLang;
            this.corpus = corpus;
            this.ngramSize = ngramSize;
        }

        /**
         * Set tokens
         * @param tokens List of tokens to filter. The tokens are separated by spaces, the list items are separated by comma (e.g., for bigrams (n&#x3D;2) tokens&#x3D;this is,this was, this will) (optional, default to a word)
         * @return GetNgramFrequenciesRequestBuilder
         */
        public GetNgramFrequenciesRequestBuilder tokens(String tokens) {
            this.tokens = tokens;
            return this;
        }
        
        /**
         * Set contains
         * @param contains Find ngrams containing the given token(s). Use comma or space as token separators; the order of tokens is irrelevant. (optional)
         * @return GetNgramFrequenciesRequestBuilder
         */
        public GetNgramFrequenciesRequestBuilder contains(String contains) {
            this.contains = contains;
            return this;
        }
        
        /**
         * Set punctuation
         * @param punctuation Flag specifying whether to lookup ngrams that include punctuation or not (possible values are \&quot;true\&quot; and \&quot;false\&quot;; default is \&quot;false\&quot;) (optional)
         * @return GetNgramFrequenciesRequestBuilder
         */
        public GetNgramFrequenciesRequestBuilder punctuation(String punctuation) {
            this.punctuation = punctuation;
            return this;
        }
        
        /**
         * Set format
         * @param format Option specifying whether tokens should be returned as a single string (option \&quot;google\&quot;) or as a list of strings (option \&quot;oup\&quot;) (optional, default to oup)
         * @return GetNgramFrequenciesRequestBuilder
         */
        public GetNgramFrequenciesRequestBuilder format(String format) {
            this.format = format;
            return this;
        }
        
        /**
         * Set minFrequency
         * @param minFrequency Restrict the query to entries with frequency of at least &#x60;minFrequency&#x60; (optional)
         * @return GetNgramFrequenciesRequestBuilder
         */
        public GetNgramFrequenciesRequestBuilder minFrequency(Long minFrequency) {
            this.minFrequency = minFrequency;
            return this;
        }
        
        /**
         * Set maxFrequency
         * @param maxFrequency Restrict the query to entries with frequency of at most &#x60;maxFrequency&#x60; (optional)
         * @return GetNgramFrequenciesRequestBuilder
         */
        public GetNgramFrequenciesRequestBuilder maxFrequency(Long maxFrequency) {
            this.maxFrequency = maxFrequency;
            return this;
        }
        
        /**
         * Set minDocumentFrequency
         * @param minDocumentFrequency Restrict the query to entries that appear in at least &#x60;minDocumentFrequency&#x60; documents (optional)
         * @return GetNgramFrequenciesRequestBuilder
         */
        public GetNgramFrequenciesRequestBuilder minDocumentFrequency(Long minDocumentFrequency) {
            this.minDocumentFrequency = minDocumentFrequency;
            return this;
        }
        
        /**
         * Set maxDocumentFrequency
         * @param maxDocumentFrequency Restrict the query to entries that appera in at most &#x60;maxDocumentFrequency&#x60; documents (optional)
         * @return GetNgramFrequenciesRequestBuilder
         */
        public GetNgramFrequenciesRequestBuilder maxDocumentFrequency(Long maxDocumentFrequency) {
            this.maxDocumentFrequency = maxDocumentFrequency;
            return this;
        }
        
        /**
         * Set collate
         * @param collate collate the results by wordform, trueCase, lemma, lexicalCategory. Multiple values can be separated by commas (e.g., collate&#x3D;trueCase,lemma,lexicalCategory). (optional)
         * @return GetNgramFrequenciesRequestBuilder
         */
        public GetNgramFrequenciesRequestBuilder collate(String collate) {
            this.collate = collate;
            return this;
        }
        
        /**
         * Set sort
         * @param sort sort the resulting list by wordform, trueCase, lemma, lexicalCategory, frequency, normalizedFrequency. Descending order is achieved by prepending the value with the minus sign (&#39;-&#39;). Multiple values can be separated by commas (e.g., sort&#x3D;lexicalCategory,-frequency) (optional)
         * @return GetNgramFrequenciesRequestBuilder
         */
        public GetNgramFrequenciesRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set offset
         * @param offset pagination - results offset (optional, default to 0)
         * @return GetNgramFrequenciesRequestBuilder
         */
        public GetNgramFrequenciesRequestBuilder offset(Long offset) {
            this.offset = offset;
            return this;
        }
        
        /**
         * Set limit
         * @param limit pagination - results limit (optional, default to 100)
         * @return GetNgramFrequenciesRequestBuilder
         */
        public GetNgramFrequenciesRequestBuilder limit(Long limit) {
            this.limit = limit;
            return this;
        }
        
        /**
         * Build call for getNgramFrequencies
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Invalid option name...  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> language is not in...  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Internal Error. An error occurred while processing the data.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getNgramFrequenciesCall(sourceLang, corpus, ngramSize, tokens, contains, punctuation, format, minFrequency, maxFrequency, minDocumentFrequency, maxDocumentFrequency, collate, sort, offset, limit, _callback);
        }


        /**
         * Execute getNgramFrequencies request
         * @return NgramsResult
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Invalid option name...  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> language is not in...  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Internal Error. An error occurred while processing the data.  </td><td>  -  </td></tr>
         </table>
         */
        public NgramsResult execute() throws ApiException {
            ApiResponse<NgramsResult> localVarResp = getNgramFrequenciesWithHttpInfo(sourceLang, corpus, ngramSize, tokens, contains, punctuation, format, minFrequency, maxFrequency, minDocumentFrequency, maxDocumentFrequency, collate, sort, offset, limit);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getNgramFrequencies request with HTTP info returned
         * @return ApiResponse&lt;NgramsResult&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Invalid option name...  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> language is not in...  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Internal Error. An error occurred while processing the data.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<NgramsResult> executeWithHttpInfo() throws ApiException {
            return getNgramFrequenciesWithHttpInfo(sourceLang, corpus, ngramSize, tokens, contains, punctuation, format, minFrequency, maxFrequency, minDocumentFrequency, maxDocumentFrequency, collate, sort, offset, limit);
        }

        /**
         * Execute getNgramFrequencies request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Invalid option name...  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> language is not in...  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Internal Error. An error occurred while processing the data.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<NgramsResult> _callback) throws ApiException {
            return getNgramFrequenciesAsync(sourceLang, corpus, ngramSize, tokens, contains, punctuation, format, minFrequency, maxFrequency, minDocumentFrequency, maxDocumentFrequency, collate, sort, offset, limit, _callback);
        }
    }

    /**
     * Retrieve the frequency of ngrams (1-4) derived from a corpus
     * This endpoint returns frequencies of ngrams of size 1-4. That is the number of times a word (ngram size &#x3D; 1) or words (ngram size &gt; 1) appear in the corpus. Ngrams are case sensitive (\&quot;I AM\&quot; and \&quot;I am\&quot; will have different frequency) and frequencies are calculated per word (true case) so \&quot;the book\&quot; and \&quot;the books\&quot; are two different ngrams. The results can be filtered based on query parameters. &lt;br&gt; &lt;br&gt; Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overridden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). &lt;br&gt; &lt;br&gt; Example for bigrams (ngram of size 2): * PATH: /tokens&#x3D;a word,another word * GET: /?tokens&#x3D;a word&amp;tokens&#x3D;another word * POST (json):    &#x60;&#x60;&#x60;javascript     {         \&quot;tokens\&quot;: [\&quot;a word\&quot;, \&quot;another word\&quot;]     }   &#x60;&#x60;&#x60;  Either \&quot;tokens\&quot; or \&quot;contains\&quot; has to be provided. &lt;br&gt; &lt;br&gt; Some queries with \&quot;contains\&quot; or \&quot;sort\&quot; can exceed the 30s timeout, in which case the API will return an error message with status code 503. You mitigate this by providing additional restrictions such as \&quot;minFrequency\&quot; and \&quot;maxFrequency\&quot;. &lt;br&gt; &lt;br&gt; You can use the parameters \&quot;offset\&quot; and \&quot;limit\&quot; to paginate through large result sets. For convenience, the HTTP header \&quot;Link\&quot; is set on the response to provide links to \&quot;first\&quot;, \&quot;self\&quot;, \&quot;next\&quot;, \&quot;prev\&quot; and \&quot;last\&quot; pages of results (depending on the context). For example, if the result set contains 50 results and the parameter \&quot;limit\&quot; is set to 25, the Links header will contain an URL for the first 25 results and the next 25 results. &lt;br&gt; &lt;br&gt; Some libraries such as python&#39;s &#x60;requests&#x60; can parse the header automatically and offer a convenient way of iterating through the results. For example: &#x60;&#x60;&#x60;python def get_all_results(url):     while url:         r &#x3D; requests.get(url)         r.raise_for_status()         for item in r.json()[&#39;results&#39;]:           yield item         url &#x3D; r.links.get(&#39;next&#39;, {}).get(&#39;url&#39;) &#x60;&#x60;&#x60; 
     * @param sourceLang IANA language code (required)
     * @param corpus For corpora other than &#39;nmc&#39; (New Monitor Corpus) please contact api@oxforddictionaries.com (required)
     * @param ngramSize the size of ngrams requested (1-4) (required)
     * @return GetNgramFrequenciesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid option name...  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> language is not in...  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Error. An error occurred while processing the data.  </td><td>  -  </td></tr>
     </table>
     */
    public GetNgramFrequenciesRequestBuilder getNgramFrequencies(String sourceLang, String corpus, String ngramSize) throws IllegalArgumentException {
        if (sourceLang == null) throw new IllegalArgumentException("\"sourceLang\" is required but got null");
            

        if (corpus == null) throw new IllegalArgumentException("\"corpus\" is required but got null");
            

        if (ngramSize == null) throw new IllegalArgumentException("\"ngramSize\" is required but got null");
            

        return new GetNgramFrequenciesRequestBuilder(sourceLang, corpus, ngramSize);
    }
    private okhttp3.Call getWordFrequenciesCall(String sourceLang, String corpus, String wordform, String trueCase, String lemma, String lexicalCategory, String grammaticalFeatures, String sort, String collate, Long minFrequency, Long maxFrequency, Float minNormalizedFrequency, Float maxNormalizedFrequency, Long offset, Long limit, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/stats/frequency/words/{source_lang}"
            .replace("{" + "source_lang" + "}", localVarApiClient.escapeString(sourceLang.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (corpus != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("corpus", corpus));
        }

        if (wordform != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("wordform", wordform));
        }

        if (trueCase != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("trueCase", trueCase));
        }

        if (lemma != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("lemma", lemma));
        }

        if (lexicalCategory != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("lexicalCategory", lexicalCategory));
        }

        if (grammaticalFeatures != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("grammaticalFeatures", grammaticalFeatures));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (collate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("collate", collate));
        }

        if (minFrequency != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minFrequency", minFrequency));
        }

        if (maxFrequency != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxFrequency", maxFrequency));
        }

        if (minNormalizedFrequency != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minNormalizedFrequency", minNormalizedFrequency));
        }

        if (maxNormalizedFrequency != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxNormalizedFrequency", maxNormalizedFrequency));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        final String[] localVarAccepts = {
            "application/json",
            "text/csv"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "appId", "appKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getWordFrequenciesValidateBeforeCall(String sourceLang, String corpus, String wordform, String trueCase, String lemma, String lexicalCategory, String grammaticalFeatures, String sort, String collate, Long minFrequency, Long maxFrequency, Float minNormalizedFrequency, Float maxNormalizedFrequency, Long offset, Long limit, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'sourceLang' is set
        if (sourceLang == null) {
            throw new ApiException("Missing the required parameter 'sourceLang' when calling getWordFrequencies(Async)");
        }

        return getWordFrequenciesCall(sourceLang, corpus, wordform, trueCase, lemma, lexicalCategory, grammaticalFeatures, sort, collate, minFrequency, maxFrequency, minNormalizedFrequency, maxNormalizedFrequency, offset, limit, _callback);

    }


    private ApiResponse<StatsWordResultList> getWordFrequenciesWithHttpInfo(String sourceLang, String corpus, String wordform, String trueCase, String lemma, String lexicalCategory, String grammaticalFeatures, String sort, String collate, Long minFrequency, Long maxFrequency, Float minNormalizedFrequency, Float maxNormalizedFrequency, Long offset, Long limit) throws ApiException {
        okhttp3.Call localVarCall = getWordFrequenciesValidateBeforeCall(sourceLang, corpus, wordform, trueCase, lemma, lexicalCategory, grammaticalFeatures, sort, collate, minFrequency, maxFrequency, minNormalizedFrequency, maxNormalizedFrequency, offset, limit, null);
        Type localVarReturnType = new TypeToken<StatsWordResultList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getWordFrequenciesAsync(String sourceLang, String corpus, String wordform, String trueCase, String lemma, String lexicalCategory, String grammaticalFeatures, String sort, String collate, Long minFrequency, Long maxFrequency, Float minNormalizedFrequency, Float maxNormalizedFrequency, Long offset, Long limit, final ApiCallback<StatsWordResultList> _callback) throws ApiException {

        okhttp3.Call localVarCall = getWordFrequenciesValidateBeforeCall(sourceLang, corpus, wordform, trueCase, lemma, lexicalCategory, grammaticalFeatures, sort, collate, minFrequency, maxFrequency, minNormalizedFrequency, maxNormalizedFrequency, offset, limit, _callback);
        Type localVarReturnType = new TypeToken<StatsWordResultList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetWordFrequenciesRequestBuilder {
        private final String sourceLang;
        private String corpus;
        private String wordform;
        private String trueCase;
        private String lemma;
        private String lexicalCategory;
        private String grammaticalFeatures;
        private String sort;
        private String collate;
        private Long minFrequency;
        private Long maxFrequency;
        private Float minNormalizedFrequency;
        private Float maxNormalizedFrequency;
        private Long offset;
        private Long limit;

        private GetWordFrequenciesRequestBuilder(String sourceLang) {
            this.sourceLang = sourceLang;
        }

        /**
         * Set corpus
         * @param corpus For corpora other than &#39;nmc&#39; (New Monitor Corpus) please contact api@oxforddictionaries.com (optional, default to nmc)
         * @return GetWordFrequenciesRequestBuilder
         */
        public GetWordFrequenciesRequestBuilder corpus(String corpus) {
            this.corpus = corpus;
            return this;
        }
        
        /**
         * Set wordform
         * @param wordform The written form of the word to look up (preserving case e.g., Book vs book) (optional)
         * @return GetWordFrequenciesRequestBuilder
         */
        public GetWordFrequenciesRequestBuilder wordform(String wordform) {
            this.wordform = wordform;
            return this;
        }
        
        /**
         * Set trueCase
         * @param trueCase The written form of the word to look up with normalised case (Books --&gt; books) (optional)
         * @return GetWordFrequenciesRequestBuilder
         */
        public GetWordFrequenciesRequestBuilder trueCase(String trueCase) {
            this.trueCase = trueCase;
            return this;
        }
        
        /**
         * Set lemma
         * @param lemma The lemma of the word to look up (e.g., Book, booked, books all have the lemma \&quot;book\&quot;) (optional, default to test)
         * @return GetWordFrequenciesRequestBuilder
         */
        public GetWordFrequenciesRequestBuilder lemma(String lemma) {
            this.lemma = lemma;
            return this;
        }
        
        /**
         * Set lexicalCategory
         * @param lexicalCategory The lexical category of the word(s) to look up (e.g., adjective or noun) (optional)
         * @return GetWordFrequenciesRequestBuilder
         */
        public GetWordFrequenciesRequestBuilder lexicalCategory(String lexicalCategory) {
            this.lexicalCategory = lexicalCategory;
            return this;
        }
        
        /**
         * Set grammaticalFeatures
         * @param grammaticalFeatures The grammatical features of the word(s) to look up entered as a list of k:v (e.g., degree_type:comparative) (optional)
         * @return GetWordFrequenciesRequestBuilder
         */
        public GetWordFrequenciesRequestBuilder grammaticalFeatures(String grammaticalFeatures) {
            this.grammaticalFeatures = grammaticalFeatures;
            return this;
        }
        
        /**
         * Set sort
         * @param sort sort the resulting list by wordform, trueCase, lemma, lexicalCategory, frequency, normalizedFrequency. Descending order is achieved by prepending the value with the minus sign (&#39;-&#39;). Multiple values can be separated by commas (e.g., sort&#x3D;lexicalCategory,-frequency) (optional)
         * @return GetWordFrequenciesRequestBuilder
         */
        public GetWordFrequenciesRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set collate
         * @param collate collate the results by wordform, trueCase, lemma, lexicalCategory. Multiple values can be separated by commas (e.g., collate&#x3D;trueCase,lemma,lexicalCategory). (optional)
         * @return GetWordFrequenciesRequestBuilder
         */
        public GetWordFrequenciesRequestBuilder collate(String collate) {
            this.collate = collate;
            return this;
        }
        
        /**
         * Set minFrequency
         * @param minFrequency Restrict the query to entries with frequency of at least &#x60;minFrequency&#x60; (optional)
         * @return GetWordFrequenciesRequestBuilder
         */
        public GetWordFrequenciesRequestBuilder minFrequency(Long minFrequency) {
            this.minFrequency = minFrequency;
            return this;
        }
        
        /**
         * Set maxFrequency
         * @param maxFrequency Restrict the query to entries with frequency of at most &#x60;maxFrequency&#x60; (optional)
         * @return GetWordFrequenciesRequestBuilder
         */
        public GetWordFrequenciesRequestBuilder maxFrequency(Long maxFrequency) {
            this.maxFrequency = maxFrequency;
            return this;
        }
        
        /**
         * Set minNormalizedFrequency
         * @param minNormalizedFrequency Restrict the query to entries with frequency of at least &#x60;minNormalizedFrequency&#x60; (optional)
         * @return GetWordFrequenciesRequestBuilder
         */
        public GetWordFrequenciesRequestBuilder minNormalizedFrequency(Float minNormalizedFrequency) {
            this.minNormalizedFrequency = minNormalizedFrequency;
            return this;
        }
        
        /**
         * Set maxNormalizedFrequency
         * @param maxNormalizedFrequency Restrict the query to entries with frequency of at most &#x60;maxNormalizedFrequency&#x60; (optional)
         * @return GetWordFrequenciesRequestBuilder
         */
        public GetWordFrequenciesRequestBuilder maxNormalizedFrequency(Float maxNormalizedFrequency) {
            this.maxNormalizedFrequency = maxNormalizedFrequency;
            return this;
        }
        
        /**
         * Set offset
         * @param offset pagination - results offset (optional, default to 0)
         * @return GetWordFrequenciesRequestBuilder
         */
        public GetWordFrequenciesRequestBuilder offset(Long offset) {
            this.offset = offset;
            return this;
        }
        
        /**
         * Set limit
         * @param limit pagination - results limit (optional, default to 100)
         * @return GetWordFrequenciesRequestBuilder
         */
        public GetWordFrequenciesRequestBuilder limit(Long limit) {
            this.limit = limit;
            return this;
        }
        
        /**
         * Build call for getWordFrequencies
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Invalid option name...; Option ... must have a value.; The option &#39;minFrequency&#39; has to have an non-negative integer parameter.; The option &#39;maxFrequency&#39; has to have an non-negative integer parameter.; The option &#39;limit&#39; has to have an non-negative integer parameter.; The option &#39;offset&#39; has to have an non-negative integer parameter. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> language is not in...  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Internal Error. An error occurred while processing the data.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getWordFrequenciesCall(sourceLang, corpus, wordform, trueCase, lemma, lexicalCategory, grammaticalFeatures, sort, collate, minFrequency, maxFrequency, minNormalizedFrequency, maxNormalizedFrequency, offset, limit, _callback);
        }


        /**
         * Execute getWordFrequencies request
         * @return StatsWordResultList
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Invalid option name...; Option ... must have a value.; The option &#39;minFrequency&#39; has to have an non-negative integer parameter.; The option &#39;maxFrequency&#39; has to have an non-negative integer parameter.; The option &#39;limit&#39; has to have an non-negative integer parameter.; The option &#39;offset&#39; has to have an non-negative integer parameter. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> language is not in...  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Internal Error. An error occurred while processing the data.  </td><td>  -  </td></tr>
         </table>
         */
        public StatsWordResultList execute() throws ApiException {
            ApiResponse<StatsWordResultList> localVarResp = getWordFrequenciesWithHttpInfo(sourceLang, corpus, wordform, trueCase, lemma, lexicalCategory, grammaticalFeatures, sort, collate, minFrequency, maxFrequency, minNormalizedFrequency, maxNormalizedFrequency, offset, limit);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getWordFrequencies request with HTTP info returned
         * @return ApiResponse&lt;StatsWordResultList&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Invalid option name...; Option ... must have a value.; The option &#39;minFrequency&#39; has to have an non-negative integer parameter.; The option &#39;maxFrequency&#39; has to have an non-negative integer parameter.; The option &#39;limit&#39; has to have an non-negative integer parameter.; The option &#39;offset&#39; has to have an non-negative integer parameter. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> language is not in...  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Internal Error. An error occurred while processing the data.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<StatsWordResultList> executeWithHttpInfo() throws ApiException {
            return getWordFrequenciesWithHttpInfo(sourceLang, corpus, wordform, trueCase, lemma, lexicalCategory, grammaticalFeatures, sort, collate, minFrequency, maxFrequency, minNormalizedFrequency, maxNormalizedFrequency, offset, limit);
        }

        /**
         * Execute getWordFrequencies request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Invalid option name...; Option ... must have a value.; The option &#39;minFrequency&#39; has to have an non-negative integer parameter.; The option &#39;maxFrequency&#39; has to have an non-negative integer parameter.; The option &#39;limit&#39; has to have an non-negative integer parameter.; The option &#39;offset&#39; has to have an non-negative integer parameter. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> language is not in...  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Internal Error. An error occurred while processing the data.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<StatsWordResultList> _callback) throws ApiException {
            return getWordFrequenciesAsync(sourceLang, corpus, wordform, trueCase, lemma, lexicalCategory, grammaticalFeatures, sort, collate, minFrequency, maxFrequency, minNormalizedFrequency, maxNormalizedFrequency, offset, limit, _callback);
        }
    }

    /**
     * Retrieve a list of frequencies of a word/words derived from a corpus.
     * This endpoint provides a list of frequencies for a given word or words. Unlike the /word/ endpoint, the results are split into the smallest units. &lt;br&gt; &lt;br&gt; To exclude a specific value, prepend it with the minus sign (&#39;-&#39;). For example, to get frequencies of the lemma &#39;happy&#39; but exclude superlative forms (i.e., happiest) you could use options &#39;lemma&#x3D;happy;grammaticalFeatures&#x3D;-degreeType:superlative&#39;. &lt;br&gt; &lt;br&gt; Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overridden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). &lt;br&gt; &lt;br&gt; The parameters wordform/trueCase/lemma/lexicalCategory also exist in a plural form, taking a lists of items. Examples: * PATH: /wordforms&#x3D;happy,happier,happiest * GET: /?wordforms&#x3D;happy&amp;wordforms&#x3D;happier&amp;wordforms&#x3D;happiest * POST (json): &#x60;&#x60;&#x60;javascript   {     \&quot;wordforms\&quot;: [\&quot;happy\&quot;, \&quot;happier\&quot;, \&quot;happiest\&quot;]   } &#x60;&#x60;&#x60; A mor complex example of retrieving frequencies of multiple lemmas: &#x60;&#x60;&#x60;   {       \&quot;lemmas\&quot;: [\&quot;happy\&quot;, \&quot;content\&quot;, \&quot;cheerful\&quot;, \&quot;cheery\&quot;, \&quot;merry\&quot;, \&quot;joyful\&quot;, \&quot;ecstatic\&quot;],       \&quot;grammaticalFeatures\&quot;: {           \&quot;adjectiveFunctionType\&quot;: \&quot;predicative\&quot;       },       \&quot;lexicalCategory\&quot;: \&quot;adjective\&quot;,       \&quot;sort\&quot;: [\&quot;lemma\&quot;, \&quot;-frequency\&quot;]   } &#x60;&#x60;&#x60; Some queries with \&quot;collate\&quot; or \&quot;sort\&quot; can exceed the 30s timeout, in which case the API will return an error message with status code 503. You mitigate this by providing additional restrictions such as \&quot;minFrequency\&quot; and \&quot;maxFrequency\&quot;. &lt;br&gt; &lt;br&gt; You can use the parameters \&quot;offset\&quot; and \&quot;limit\&quot; to paginate through large result sets. For convenience, the HTTP header \&quot;Link\&quot; is set on the response to provide links to \&quot;first\&quot;, \&quot;self\&quot;, \&quot;next\&quot;, \&quot;prev\&quot; and \&quot;last\&quot; pages of results (depending on the context). For example, if the result set contains 50 results and the parameter \&quot;limit\&quot; is set to 25, the Links header will contain an URL for the first 25 results and the next 25 results. &lt;br&gt; &lt;br&gt; Some libraries such as python&#39;s &#x60;requests&#x60; can parse the header automatically and offer a convenient way of iterating through the results. For example: &#x60;&#x60;&#x60;python def get_all_results(url):     while url:         r &#x3D; requests.get(url)         r.raise_for_status()         for item in r.json()[&#39;results&#39;]:           yield item         url &#x3D; r.links.get(&#39;next&#39;, {}).get(&#39;url&#39;) &#x60;&#x60;&#x60; 
     * @param sourceLang IANA language code (required)
     * @return GetWordFrequenciesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid option name...; Option ... must have a value.; The option &#39;minFrequency&#39; has to have an non-negative integer parameter.; The option &#39;maxFrequency&#39; has to have an non-negative integer parameter.; The option &#39;limit&#39; has to have an non-negative integer parameter.; The option &#39;offset&#39; has to have an non-negative integer parameter. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> language is not in...  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Error. An error occurred while processing the data.  </td><td>  -  </td></tr>
     </table>
     */
    public GetWordFrequenciesRequestBuilder getWordFrequencies(String sourceLang) throws IllegalArgumentException {
        if (sourceLang == null) throw new IllegalArgumentException("\"sourceLang\" is required but got null");
            

        return new GetWordFrequenciesRequestBuilder(sourceLang);
    }
    private okhttp3.Call getWordFrequencyCall(String sourceLang, String corpus, String wordform, String trueCase, String lemma, String lexicalCategory, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/stats/frequency/word/{source_lang}"
            .replace("{" + "source_lang" + "}", localVarApiClient.escapeString(sourceLang.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (corpus != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("corpus", corpus));
        }

        if (wordform != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("wordform", wordform));
        }

        if (trueCase != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("trueCase", trueCase));
        }

        if (lemma != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("lemma", lemma));
        }

        if (lexicalCategory != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("lexicalCategory", lexicalCategory));
        }

        final String[] localVarAccepts = {
            "application/json",
            "text/csv"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "appId", "appKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getWordFrequencyValidateBeforeCall(String sourceLang, String corpus, String wordform, String trueCase, String lemma, String lexicalCategory, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'sourceLang' is set
        if (sourceLang == null) {
            throw new ApiException("Missing the required parameter 'sourceLang' when calling getWordFrequency(Async)");
        }

        return getWordFrequencyCall(sourceLang, corpus, wordform, trueCase, lemma, lexicalCategory, _callback);

    }


    private ApiResponse<StatsWordResult> getWordFrequencyWithHttpInfo(String sourceLang, String corpus, String wordform, String trueCase, String lemma, String lexicalCategory) throws ApiException {
        okhttp3.Call localVarCall = getWordFrequencyValidateBeforeCall(sourceLang, corpus, wordform, trueCase, lemma, lexicalCategory, null);
        Type localVarReturnType = new TypeToken<StatsWordResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getWordFrequencyAsync(String sourceLang, String corpus, String wordform, String trueCase, String lemma, String lexicalCategory, final ApiCallback<StatsWordResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = getWordFrequencyValidateBeforeCall(sourceLang, corpus, wordform, trueCase, lemma, lexicalCategory, _callback);
        Type localVarReturnType = new TypeToken<StatsWordResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetWordFrequencyRequestBuilder {
        private final String sourceLang;
        private String corpus;
        private String wordform;
        private String trueCase;
        private String lemma;
        private String lexicalCategory;

        private GetWordFrequencyRequestBuilder(String sourceLang) {
            this.sourceLang = sourceLang;
        }

        /**
         * Set corpus
         * @param corpus For corpora other than &#39;nmc&#39; (New Monitor Corpus) please contact api@oxforddictionaries.com (optional, default to nmc)
         * @return GetWordFrequencyRequestBuilder
         */
        public GetWordFrequencyRequestBuilder corpus(String corpus) {
            this.corpus = corpus;
            return this;
        }
        
        /**
         * Set wordform
         * @param wordform The written form of the word to look up (preserving case e.g., Books vs books) (optional)
         * @return GetWordFrequencyRequestBuilder
         */
        public GetWordFrequencyRequestBuilder wordform(String wordform) {
            this.wordform = wordform;
            return this;
        }
        
        /**
         * Set trueCase
         * @param trueCase The written form of the word to look up with normalised case (Books --&gt; books) (optional)
         * @return GetWordFrequencyRequestBuilder
         */
        public GetWordFrequencyRequestBuilder trueCase(String trueCase) {
            this.trueCase = trueCase;
            return this;
        }
        
        /**
         * Set lemma
         * @param lemma The lemma of the word to look up (e.g., Book, booked, books all have the lemma \&quot;book\&quot;) (optional, default to test)
         * @return GetWordFrequencyRequestBuilder
         */
        public GetWordFrequencyRequestBuilder lemma(String lemma) {
            this.lemma = lemma;
            return this;
        }
        
        /**
         * Set lexicalCategory
         * @param lexicalCategory The lexical category of the word(s) to look up (e.g., noun or verb) (optional)
         * @return GetWordFrequencyRequestBuilder
         */
        public GetWordFrequencyRequestBuilder lexicalCategory(String lexicalCategory) {
            this.lexicalCategory = lexicalCategory;
            return this;
        }
        
        /**
         * Build call for getWordFrequency
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> You need to specify at least one option. Try one of &#39;wordform, lemma, trueCase, lexicalCategory&#39;.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> language is not in...  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Internal Error. An error occurred while processing the data.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getWordFrequencyCall(sourceLang, corpus, wordform, trueCase, lemma, lexicalCategory, _callback);
        }


        /**
         * Execute getWordFrequency request
         * @return StatsWordResult
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> You need to specify at least one option. Try one of &#39;wordform, lemma, trueCase, lexicalCategory&#39;.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> language is not in...  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Internal Error. An error occurred while processing the data.  </td><td>  -  </td></tr>
         </table>
         */
        public StatsWordResult execute() throws ApiException {
            ApiResponse<StatsWordResult> localVarResp = getWordFrequencyWithHttpInfo(sourceLang, corpus, wordform, trueCase, lemma, lexicalCategory);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getWordFrequency request with HTTP info returned
         * @return ApiResponse&lt;StatsWordResult&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> You need to specify at least one option. Try one of &#39;wordform, lemma, trueCase, lexicalCategory&#39;.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> language is not in...  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Internal Error. An error occurred while processing the data.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<StatsWordResult> executeWithHttpInfo() throws ApiException {
            return getWordFrequencyWithHttpInfo(sourceLang, corpus, wordform, trueCase, lemma, lexicalCategory);
        }

        /**
         * Execute getWordFrequency request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> You need to specify at least one option. Try one of &#39;wordform, lemma, trueCase, lexicalCategory&#39;.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> language is not in...  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Internal Error. An error occurred while processing the data.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<StatsWordResult> _callback) throws ApiException {
            return getWordFrequencyAsync(sourceLang, corpus, wordform, trueCase, lemma, lexicalCategory, _callback);
        }
    }

    /**
     * Retrieve the frequency of a word derived from a corpus.
     * This endpoint provides the frequency of a given word. When multiple database records match the query parameters, the returned frequency is the sum of the individual frequencies. For example, if the query parameters are lemma&#x3D;test, the returned frequency will include the verb \&quot;test\&quot;, the noun \&quot;test\&quot; and the adjective \&quot;test\&quot; in all forms (Test, tested, testing, etc.) &lt;br&gt; &lt;br&gt; If you are interested in the frequency of the word \&quot;test\&quot; but want to exclude other forms (e.g., tested) use the option trueCase&#x3D;test. Normally, the word \&quot;test\&quot; will be spelt with a capital letter at the beginning of a sentence. The option trueCase will ignore this and it will count \&quot;Test\&quot; and \&quot;test\&quot; as the same token. If you are interested in frequencies of \&quot;Test\&quot; and \&quot;test\&quot;, use the option wordform&#x3D;test or wordform&#x3D;Test. Note that trueCase is not just a lower case of the word as some words are genuinely spelt with a capital letter such as the word \&quot;press\&quot; in Oxford University Press. &lt;br&gt; &lt;br&gt; Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overriden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). Examples: * PATH: /lemma&#x3D;test;lexicalCategory&#x3D;noun * GET: /?lemma&#x3D;test&amp;lexicalCategory&#x3D;noun * POST (json):    &#x60;&#x60;&#x60;javascript     {       \&quot;lemma\&quot;: \&quot;test\&quot;,       \&quot;lexicalCategory\&quot;: \&quot;noun\&quot;     }   &#x60;&#x60;&#x60;  &lt;br&gt; One of the options wordform/trueCase/lemma/lexicalCategory has to be provided. 
     * @param sourceLang IANA language code (required)
     * @return GetWordFrequencyRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> You need to specify at least one option. Try one of &#39;wordform, lemma, trueCase, lexicalCategory&#39;.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> language is not in...  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Error. An error occurred while processing the data.  </td><td>  -  </td></tr>
     </table>
     */
    public GetWordFrequencyRequestBuilder getWordFrequency(String sourceLang) throws IllegalArgumentException {
        if (sourceLang == null) throw new IllegalArgumentException("\"sourceLang\" is required but got null");
            

        return new GetWordFrequencyRequestBuilder(sourceLang);
    }
}
